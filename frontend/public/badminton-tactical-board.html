<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ç¾½çƒæˆ°è¡“ç‰ˆ</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:#1a1a2e;touch-action:none;}

/* â”€â”€ Portrait è­¦å‘Š â”€â”€ */
#portrait-warning{
  display:none;position:fixed;inset:0;z-index:9999;
  background:#1a1a2e;flex-direction:column;
  align-items:center;justify-content:center;gap:16px;text-align:center;color:#eee;
}
@media(orientation:portrait){#portrait-warning{display:flex;}}
#portrait-warning .icon{font-size:3.5rem;animation:spin 2s ease-in-out infinite;}
@keyframes spin{0%,100%{transform:rotate(0deg);}50%{transform:rotate(90deg);}}

/* â”€â”€ App â”€â”€ */
#app{display:flex;flex-direction:column;height:100vh;width:100vw;}

/* â”€â”€ Toolbar â”€â”€ */
#toolbar{
  display:flex;align-items:center;gap:4px;flex-wrap:nowrap;
  padding:5px 8px;background:#16213e;
  border-bottom:1px solid #0f3460;flex-shrink:0;
  overflow-x:auto;scrollbar-width:none;-ms-overflow-style:none;
}
#toolbar::-webkit-scrollbar{display:none;}

/* â”€â”€ å·¥å…·åˆ—åœ–ç¤ºæŒ‰éˆ• â”€â”€ */
.tbtn{
  min-width:40px;min-height:40px;
  border-radius:8px;border:1.5px solid rgba(255,255,255,0.1);
  background:rgba(15,52,96,0.7);color:#ccc;
  cursor:pointer;font-size:10px;
  display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;
  padding:4px 7px;
  user-select:none;touch-action:manipulation;
  transition:background .12s, border-color .12s;
  flex-shrink:0;
}
.tbtn svg{flex-shrink:0;}
.tbtn .tl{font-size:9px;line-height:1;color:inherit;white-space:nowrap;}
.tbtn:hover,.tbtn:active{background:rgba(36,113,163,0.7);border-color:#3498db;}
.tbtn.on{background:rgba(36,113,163,0.9);border-color:#3498db;color:#fff;}
.tbtn.danger{border-color:rgba(231,76,60,.4);}
.tbtn.danger:hover,.tbtn.danger:active{background:rgba(192,57,43,0.7);}

/* å·¥å…·åˆ—åˆ†çµ„åˆ†éš”ç·š */
.sep-v{width:1px;min-height:30px;background:rgba(255,255,255,0.12);flex-shrink:0;align-self:center;margin:0 2px;}
.tlabel{font-size:8px;color:#556;text-transform:uppercase;letter-spacing:.5px;writing-mode:horizontal-tb;white-space:nowrap;align-self:center;margin:0 1px;}

/* å·¥å…·åˆ—æ”¶åˆ */
#btn-tb-hide{
  margin-left:auto;min-width:32px;min-height:32px;flex-shrink:0;
  border-radius:6px;border:1px solid rgba(255,255,255,0.1);
  background:rgba(60,60,80,0.4);color:#667;cursor:pointer;font-size:9px;
  display:flex;flex-direction:column;align-items:center;justify-content:center;gap:1px;
}
#btn-tb-hide:hover{background:rgba(80,80,110,0.7);color:#99a;}
#toolbar-reveal{
  display:none;position:fixed;top:4px;left:50%;transform:translateX(-50%);
  z-index:200;background:rgba(15,52,96,0.95);border:1px solid #3498db;
  color:#7bc;border-radius:12px;padding:4px 14px;font-size:11px;
  cursor:pointer;white-space:nowrap;box-shadow:0 2px 10px rgba(0,0,0,0.6);
  user-select:none;
}
#toolbar-reveal:hover{background:rgba(30,80,140,0.95);}

/* HUD æ”¶åˆ */
#btn-hud-hide{
  align-self:flex-end;
  border-radius:6px;border:1px solid rgba(255,255,255,0.1);
  background:rgba(40,45,65,0.6);color:#667;cursor:pointer;font-size:9px;
  padding:3px 9px;
  display:flex;align-items:center;gap:3px;white-space:nowrap;
  touch-action:manipulation;
}
#btn-hud-hide:hover{background:rgba(80,80,110,0.7);color:#99a;}
#hud-reveal{
  display:none;position:absolute;bottom:10px;left:10px;z-index:20;
  background:rgba(15,52,96,0.95);border:1px solid #3498db;
  color:#7bc;border-radius:12px;padding:4px 14px;font-size:11px;
  cursor:pointer;white-space:nowrap;box-shadow:0 2px 10px rgba(0,0,0,0.6);
  user-select:none;
}
#hud-reveal:hover{background:rgba(30,80,140,0.95);}

/* â”€â”€ ä¸»å…§å®¹ â”€â”€ */
#main{display:flex;flex:1;overflow:hidden;min-height:0;}

/* â”€â”€ å ´åœ°å®¹å™¨ â”€â”€ */
#court-container{
  flex:1;display:flex;align-items:center;justify-content:center;
  padding:6px;overflow:hidden;position:relative;
}
#court-wrapper{position:relative;}
canvas{display:block;}
#draw-canvas{position:absolute;top:0;left:0;cursor:crosshair;}

/* â•â• è¨“ç·´é¢æ¿ â•â• */
#train-panel{
  display:none;position:absolute;top:8px;right:8px;z-index:30;
  background:rgba(15,25,50,0.95);border:1.5px solid #1a6;
  border-radius:10px;padding:10px 12px;min-width:180px;
  box-shadow:0 4px 18px rgba(0,0,0,0.7);color:#cef;font-size:11px;
}
#train-panel.open{display:block;}
#train-panel h4{margin:0 0 8px;font-size:12px;color:#4f9;text-align:center;letter-spacing:.5px;}
.tp-row{display:flex;align-items:center;gap:6px;margin-bottom:7px;flex-wrap:wrap;}
.tp-label{font-size:10px;color:#89c;min-width:30px;}
.tp-btn{
  padding:3px 9px;border-radius:6px;border:1.5px solid rgba(255,255,255,0.15);
  background:rgba(15,52,96,0.7);color:#adf;font-size:11px;cursor:pointer;
  transition:background .12s;
}
.tp-btn.on{background:rgba(0,180,80,0.7);border-color:#0d9;color:#fff;}
.tp-btn:hover{background:rgba(36,113,163,0.6);}
.tp-sep{width:100%;height:1px;background:rgba(255,255,255,0.1);margin:4px 0;}
#train-start{
  width:100%;padding:6px;border-radius:7px;border:none;
  background:#1a7a30;color:#fff;font-size:12px;font-weight:bold;cursor:pointer;
}
#train-start.running{background:#8b1a1a;}
#train-start:hover{filter:brightness(1.2);}
.train-speed{
  width:90px;accent-color:#1a6;vertical-align:middle;
}
.tp-hint{font-size:9px;color:#556;text-align:center;margin-top:4px;}

/* â”€â”€ è¨“ç·´ç‡ˆè¦†è“‹å±¤ â”€â”€ */
#train-overlay{
  position:absolute;top:0;left:0;width:100%;height:100%;
  pointer-events:none;z-index:25;display:none;
}
#train-overlay.active{display:block;}

/* â”€â”€ å ´åœ°å´é‚Šæ¨™ç±¤ â”€â”€ */
#side-labels{
  position:absolute;top:0;left:0;width:100%;height:100%;
  display:flex;pointer-events:none;
}
.side-lbl{flex:1;display:flex;align-items:flex-start;justify-content:center;padding-top:4px;font-size:9px;font-weight:bold;opacity:.8;}

/* â”€â”€ ç™¼çƒæ¨™èªŒ â”€â”€ */
#serve-flag{
  position:absolute;font-size:18px;pointer-events:none;
  filter:drop-shadow(0 0 3px gold);display:none;
}

/* â•â•â• æµ®å‹• HUD â•â•â• */
#hud{
  position:absolute;bottom:10px;left:10px;z-index:20;
  display:flex;flex-direction:column;gap:6px;
  user-select:none;
}

/* HUD ç¾¤çµ„è¡Œ */
.hud-row{display:flex;align-items:center;gap:5px;}
.hud-sep{font-size:8px;color:#557;text-transform:uppercase;letter-spacing:.5px;white-space:nowrap;min-width:24px;}

/* â”€â”€ çƒå“¡æ£‹å­ â”€â”€ */
.hud-player{
  width:42px;height:42px;border-radius:50%;
  border:2.5px solid rgba(255,255,255,0.2);
  background:var(--c);cursor:pointer;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  font-weight:800;color:#fff;
  box-shadow:0 2px 8px rgba(0,0,0,0.5);
  transition:border-color .12s, transform .1s;
  touch-action:manipulation;
  position:relative;overflow:hidden;
}
.hud-player:hover{transform:scale(1.08);}
.hud-player.sel{border-color:#fff;box-shadow:0 0 0 3px rgba(255,255,255,0.5),0 2px 8px rgba(0,0,0,0.5);}
.hud-player.pending{border-color:#facc15;box-shadow:0 0 0 3px rgba(250,204,21,0.6),0 2px 8px rgba(0,0,0,0.5);animation:pulse-place .8s ease-in-out infinite;}
.hud-player .pnum{font-size:15px;font-weight:800;line-height:1;}
.hud-player .plbl{font-size:7.5px;opacity:.85;line-height:1;}

/* â”€â”€ çƒæ£‹å­ â”€â”€ */
.hud-ball{
  width:38px;height:38px;border-radius:50%;
  border:2.5px solid rgba(255,255,255,0.2);
  background:rgba(30,35,55,0.9);cursor:pointer;
  display:flex;align-items:center;justify-content:center;
  box-shadow:0 2px 8px rgba(0,0,0,0.5);
  transition:border-color .12s, transform .1s;
  touch-action:manipulation;
}
.hud-ball:hover{transform:scale(1.08);}
.hud-ball.sel{border-color:#fff;box-shadow:0 0 0 3px rgba(255,255,255,0.5);}
.hud-ball.pending{border-color:#facc15;box-shadow:0 0 0 3px rgba(250,204,21,0.6);animation:pulse-place .8s ease-in-out infinite;}

/* â”€â”€ æ¨™è¨˜é¡è‰² â”€â”€ */
.hud-annot{
  width:30px;height:30px;border-radius:50%;
  border:2.5px solid rgba(255,255,255,0.15);
  background:var(--c);cursor:pointer;
  box-shadow:0 2px 6px rgba(0,0,0,0.4);
  transition:border-color .12s, transform .1s;
  touch-action:manipulation;
  position:relative;
}
.hud-annot:hover{transform:scale(1.12);}
.hud-annot.sel{border-color:#fff;box-shadow:0 0 0 3px rgba(255,255,255,0.5);transform:scale(1.12);}

/* HUD æ“ä½œæŒ‰éˆ• */
.hud-btn{
  height:34px;border-radius:8px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(15,20,40,0.75);
  color:#ccc;cursor:pointer;font-size:11px;
  padding:0 10px;
  display:flex;align-items:center;gap:3px;
  box-shadow:0 2px 6px rgba(0,0,0,0.4);
  backdrop-filter:blur(8px);
  touch-action:manipulation;
  transition:background .12s;
  white-space:nowrap;
}
.hud-btn:hover,.hud-btn:active{background:rgba(36,113,163,0.75);}
.hud-btn.danger{border-color:rgba(231,76,60,.3);}
.hud-btn.danger:hover,.hud-btn.danger:active{background:rgba(192,57,43,0.7);}

@keyframes pulse-place{
  0%,100%{box-shadow:0 0 0 3px rgba(250,204,21,0.6),0 2px 8px rgba(0,0,0,0.5);}
  50%{box-shadow:0 0 0 6px rgba(250,204,21,0.3),0 2px 8px rgba(0,0,0,0.5);}
}
</style>
</head>
<body>

<!-- è±å±è­¦å‘Š -->
<div id="portrait-warning">
  <div class="icon">ğŸ“±</div>
  <h2 style="font-size:1.2rem">è«‹å°‡è£ç½®æ—‹è½‰ç‚ºæ©«å‘</h2>
  <p style="color:#888;font-size:12px">Rotate to landscape to use the tactical board</p>
</div>

<div id="app">

  <!-- â•â•â•â• å·¥å…·åˆ— â•â•â•â• -->
  <div id="toolbar">

    <!-- æ¨¡å¼ -->
    <span class="tlabel">æ¨¡å¼</span>
    <button class="tbtn on" id="btn-draw" onclick="setMode('draw')" title="èµ°ç·š [Q]">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 2.5l2.5 2.5-7.5 7.5-3 .5.5-3z"/><line x1="11" y1="2.5" x2="13.5" y2="5"/>
      </svg>
      <span class="tl">èµ°ç·š</span>
    </button>
    <button class="tbtn" id="btn-place" onclick="setMode('place')" title="ç«™ä½ [W]">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
        <circle cx="8" cy="4.5" r="2.2"/><path d="M3.5 14c0-2.5 2-4.5 4.5-4.5s4.5 2 4.5 4.5"/>
      </svg>
      <span class="tl">ç«™ä½</span>
    </button>
    <button class="tbtn" id="btn-erase" onclick="setMode('erase')" title="æ“¦é™¤ [E]">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="1.5" y="7" width="13" height="6" rx="1.5"/>
        <path d="M5 7V5.5a3 3 0 0 1 6 0V7"/>
        <line x1="8" y1="10" x2="8" y2="11"/>
      </svg>
      <span class="tl">æ“¦é™¤</span>
    </button>

    <div class="sep-v"></div>

    <!-- å ´å‹ -->
    <span class="tlabel">å ´å‹</span>
    <button class="tbtn on" id="btn-doubles" onclick="setCourtType('doubles')" title="é›™æ‰“ [S]">
      <svg width="20" height="14" viewBox="0 0 20 14" fill="none" stroke="currentColor" stroke-linecap="round">
        <rect x="1" y="1" width="18" height="12" rx="0.5" stroke-width="1.5"/>
        <line x1="10" y1="1" x2="10" y2="13" stroke-width="1.2"/>
        <line x1="1" y1="3" x2="19" y2="3" stroke-width="0.8"/>
        <line x1="1" y1="11" x2="19" y2="11" stroke-width="0.8"/>
      </svg>
      <span class="tl">é›™æ‰“</span>
    </button>
    <button class="tbtn" id="btn-singles" onclick="setCourtType('singles')" title="å–®æ‰“ [S]">
      <svg width="20" height="14" viewBox="0 0 20 14" fill="none" stroke="currentColor" stroke-linecap="round">
        <rect x="1" y="1" width="18" height="12" rx="0.5" stroke-width="1" opacity="0.35"/>
        <rect x="3.5" y="1" width="13" height="12" rx="0.5" stroke-width="1.5"/>
        <line x1="10" y1="1" x2="10" y2="13" stroke-width="1.2"/>
        <line x1="3.5" y1="4.5" x2="16.5" y2="4.5" stroke-width="0.8"/>
        <line x1="3.5" y1="9.5" x2="16.5" y2="9.5" stroke-width="0.8"/>
      </svg>
      <span class="tl">å–®æ‰“</span>
    </button>

    <div class="sep-v"></div>

    <!-- ç·šæ¢æ¨£å¼ -->
    <span class="tlabel">ç·šæ¢</span>
    <button class="tbtn on" id="btn-solid" onclick="setDash('solid')" title="å¯¦ç·š">
      <svg width="22" height="10" viewBox="0 0 22 10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="2" y1="5" x2="20" y2="5"/>
      </svg>
      <span class="tl">å¯¦ç·š</span>
    </button>
    <button class="tbtn" id="btn-dashed" onclick="setDash('dashed')" title="è™›ç·š">
      <svg width="22" height="10" viewBox="0 0 22 10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="4 3">
        <line x1="2" y1="5" x2="20" y2="5"/>
      </svg>
      <span class="tl">è™›ç·š</span>
    </button>
    <input type="range" id="lw" min="1" max="8" value="3"
           style="width:52px;accent-color:#3498db;align-self:center;"
           oninput="state.lineWidth=+this.value" title="ç·šæ¢ç²—ç´°">

    <div class="sep-v"></div>

    <!-- ç™¼çƒ -->
    <span class="tlabel">ç™¼çƒ</span>
    <button class="tbtn" id="btn-sl" onclick="setServe('left')" title="å·¦ç™¼çƒ [A]">
      <svg width="16" height="14" viewBox="0 0 16 14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="10,2 3,7 10,12"/>
        <line x1="13" y1="7" x2="4" y2="7"/>
      </svg>
      <span class="tl">å·¦ç™¼</span>
    </button>
    <button class="tbtn" id="btn-sr" onclick="setServe('right')" title="å³ç™¼çƒ [D]">
      <svg width="16" height="14" viewBox="0 0 16 14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="6,2 13,7 6,12"/>
        <line x1="3" y1="7" x2="12" y2="7"/>
      </svg>
      <span class="tl">å³ç™¼</span>
    </button>
    <button class="tbtn" id="btn-sn" onclick="setServe('none')" title="æ¸…é™¤ç™¼çƒ">
      <svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
        <line x1="2" y1="2" x2="12" y2="12"/><line x1="12" y1="2" x2="2" y2="12"/>
      </svg>
      <span class="tl">æ¸…ç™¼</span>
    </button>

    <div class="sep-v"></div>

    <!-- æˆ‘æ–¹åœ¨ -->
    <span class="tlabel">æˆ‘æ–¹</span>
    <button class="tbtn on" id="btn-hl" onclick="setHome('left')" title="æˆ‘æ–¹åœ¨å·¦">
      <svg width="18" height="14" viewBox="0 0 18 14" fill="none" stroke="currentColor" stroke-linecap="round">
        <rect x="1" y="1" width="16" height="12" rx="0.5" stroke-width="1" opacity="0.35"/>
        <rect x="1" y="1" width="8" height="12" rx="0.5" stroke-width="1.5" fill="rgba(52,152,219,0.25)"/>
        <line x1="9" y1="1" x2="9" y2="13" stroke-width="1.2"/>
      </svg>
      <span class="tl">æˆ‘å·¦</span>
    </button>
    <button class="tbtn" id="btn-hr" onclick="setHome('right')" title="æˆ‘æ–¹åœ¨å³">
      <svg width="18" height="14" viewBox="0 0 18 14" fill="none" stroke="currentColor" stroke-linecap="round">
        <rect x="1" y="1" width="16" height="12" rx="0.5" stroke-width="1" opacity="0.35"/>
        <rect x="9" y="1" width="8" height="12" rx="0.5" stroke-width="1.5" fill="rgba(52,152,219,0.25)"/>
        <line x1="9" y1="1" x2="9" y2="13" stroke-width="1.2"/>
      </svg>
      <span class="tl">æˆ‘å³</span>
    </button>

    <div class="sep-v"></div>

    <!-- è¨“ç·´æ¨¡å¼ -->
    <button class="tbtn" id="btn-train" onclick="toggleTrainPanel()" title="ç±³å­—æ­¥è¨“ç·´">
      <svg width="20" height="18" viewBox="0 0 20 18" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
        <circle cx="10" cy="9" r="2.5" fill="rgba(0,200,80,0.3)" stroke="#0c6"/>
        <circle cx="4"  cy="3"  r="2"  fill="rgba(0,200,80,0.15)"/>
        <circle cx="16" cy="3"  r="2"  fill="rgba(0,200,80,0.15)"/>
        <circle cx="4"  cy="15" r="2"  fill="rgba(0,200,80,0.15)"/>
        <circle cx="16" cy="15" r="2"  fill="rgba(0,200,80,0.15)"/>
        <circle cx="4"  cy="9"  r="2"  fill="rgba(0,200,80,0.15)"/>
        <circle cx="16" cy="9"  r="2"  fill="rgba(0,200,80,0.15)"/>
      </svg>
      <span class="tl">è¨“ç·´</span>
    </button>

    <div class="sep-v"></div>

    <!-- æ“ä½œ -->
    <button class="tbtn" onclick="undo()" title="å¾©åŸ Ctrl+Z">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5 8H10a3 3 0 0 1 0 6H6"/><polyline points="8,5.5 5,8 8,10.5"/></svg>
      <span class="tl">å¾©åŸ</span>
    </button>
    <button class="tbtn" onclick="clearActive()" title="æ¸…é™¤é¸å–ç­†è·¡">
      <svg width="14" height="15" viewBox="0 0 14 15" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="1,3.5 13,3.5"/><path d="M4,3.5V2h6v1.5"/><rect x="2" y="3.5" width="10" height="9" rx="1"/><line x1="5" y1="6.5" x2="5" y2="10.5"/><line x1="9" y1="6.5" x2="9" y2="10.5"/></svg>
      <span class="tl">æ¸…è·¡</span>
    </button>
    <button class="tbtn danger" onclick="resetAll()" title="å…¨éƒ¨é‡ç½® [R]">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 8A5 5 0 1 1 10 3.3"/><polyline points="14,1 14,5 10,5"/></svg>
      <span class="tl">é‡ç½®</span>
    </button>

    <!-- æ”¶åˆæŒ‰éˆ•ï¼ˆå·¥å…·åˆ—æœ€å³å´ï¼‰ -->
    <button id="btn-tb-hide" onclick="hideToolbar()" title="æ”¶åˆå·¥å…·åˆ—">
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
        <polyline points="2,8 6,4 10,8"/>
      </svg>
      <span style="font-size:8px;color:inherit;">æ”¶</span>
    </button>
  </div><!-- /toolbar -->

  <!-- å·¥å…·åˆ—éš±è—æ™‚çš„é¡¯ç¤ºæŒ‰éˆ• -->
  <div id="toolbar-reveal" onclick="showToolbar()">â–¼ å·¥å…·åˆ—</div>

  <!-- ä¸»å€åŸŸ -->
  <div id="main">
    <div id="court-container">
      <div id="court-wrapper">
        <canvas id="court-canvas"></canvas>
        <canvas id="draw-canvas"></canvas>

        <!-- ä¸»å®¢å ´æ¨™ç±¤ -->
        <div id="side-labels">
          <div class="side-lbl" id="lbl-left"  style="color:#3498db">ğŸ”µæˆ‘æ–¹</div>
          <div class="side-lbl" id="lbl-right" style="color:#e74c3c">ğŸ”´å°æ–¹</div>
        </div>

        <!-- ç™¼çƒæ—— -->
        <div id="serve-flag">ğŸ¸</div>

        <!-- â•â•â•â• è¨“ç·´ç‡ˆè¦†è“‹å±¤ (Canvas) â•â•â•â• -->
        <canvas id="train-overlay"></canvas>

        <!-- â•â•â•â• è¨“ç·´é¢æ¿ â•â•â•â• -->
        <div id="train-panel">
          <h4>ğŸƒ ç±³å­—æ­¥è¨“ç·´</h4>

          <!-- è¨“ç·´å´åˆ¥ -->
          <div class="tp-row">
            <span class="tp-label">å´åˆ¥</span>
            <button class="tp-btn on" id="tp-home" onclick="setTrainSide('home')">æˆ‘æ–¹</button>
            <button class="tp-btn"    id="tp-away" onclick="setTrainSide('away')">å°æ–¹</button>
          </div>

          <!-- è¨“ç·´å€åŸŸ -->
          <div class="tp-row">
            <span class="tp-label">å€åŸŸ</span>
            <button class="tp-btn on" id="tp-front" onclick="toggleTrainZone('front')">å‰2</button>
            <button class="tp-btn on" id="tp-mid"   onclick="toggleTrainZone('mid')">ä¸­2</button>
            <button class="tp-btn on" id="tp-back"  onclick="toggleTrainZone('back')">å¾Œ2</button>
          </div>

          <div class="tp-sep"></div>

          <!-- é€Ÿåº¦ -->
          <div class="tp-row">
            <span class="tp-label">é–“éš”</span>
            <input class="train-speed" type="range" id="tp-speed" min="5" max="30" value="10"
                   oninput="setTrainInterval(this.value)">
            <span id="tp-speed-val" style="font-size:10px;color:#9bf;">2.0s</span>
          </div>

          <!-- é–‹å§‹/åœæ­¢ -->
          <button id="train-start" onclick="toggleTraining()">â–¶ é–‹å§‹è¨“ç·´</button>

          <div class="tp-hint">ğŸŸ¢ æˆ‘æ–¹ç«™ä½ â†‘ä¸Šæ‰‹ â†“ä¸‹æ‰‹<br>ğŸŸ  å°æ–¹ç›®æ¨™è½é»</div>
        </div>

        <!-- â•â•â•â• æµ®å‹• HUD â•â•â•â• -->
        <div id="hud">

          <!-- æ”¶åˆæŒ‰éˆ• -->
          <button id="btn-hud-hide" onclick="hideHud()" title="æ”¶åˆ HUD">
            â–¾&nbsp;HUD
            <svg width="9" height="7" viewBox="0 0 9 7" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><polyline points="1,2 4.5,5.5 8,2"/></svg>
          </button>

          <!-- çƒå“¡é¸æ“‡ -->
          <div class="hud-row">
            <span class="hud-sep">çƒå“¡</span>
            <div id="hud-players"></div>
          </div>

          <!-- çƒé¸æ“‡ (1å€‹) -->
          <div class="hud-row">
            <span class="hud-sep">çƒ</span>
            <div id="hud-ball"></div>
          </div>

          <!-- æ¨™è¨˜é¡è‰² -->
          <div class="hud-row">
            <span class="hud-sep">æ¨™è¨˜</span>
            <div id="hud-annots" style="display:flex;gap:4px;"></div>
          </div>

        </div><!-- /hud -->

        <!-- HUD éš±è—æ™‚çš„é¡¯ç¤ºæŒ‰éˆ• -->
        <div id="hud-reveal" onclick="showHud()">â–´ HUD</div>

      </div>
    </div>
  </div>

</div><!-- /app -->

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// å¯¦é«”è³‡æ–™
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PLAYERS = [
  {id:0, name:'P1', label:'çƒå“¡1', color:'#E74C3C', visible:true, pos:null, strokes:[]},
  {id:1, name:'P2', label:'çƒå“¡2', color:'#3498DB', visible:true, pos:null, strokes:[]},
  {id:2, name:'P3', label:'çƒå“¡3', color:'#2ECC71', visible:true, pos:null, strokes:[]},
  {id:3, name:'P4', label:'çƒå“¡4', color:'#F39C12', visible:true, pos:null, strokes:[]},
];

// åªæœ‰ 1 å€‹çƒ
const BALLS = [
  {id:0, name:'çƒ', color:'#ffffff', borderColor:'#bbbbbb', visible:true, pos:null, strokes:[]},
];

// æˆ°è¡“æ¨™è¨˜è‰²çµ„ï¼ˆç„¡ä½ç½®ï¼Œåªç•«ç·šï¼‰
const ANNOTS = [
  {id:0, color:'#E74C3C', label:'ç´…', strokes:[]},
  {id:1, color:'#F39C12', label:'æ©™', strokes:[]},
  {id:2, color:'#F1C40F', label:'é»ƒ', strokes:[]},
  {id:3, color:'#2ECC71', label:'ç¶ ', strokes:[]},
  {id:4, color:'#5DADE2', label:'æ·ºè—', strokes:[]},
  {id:5, color:'#9B59B6', label:'ç´«', strokes:[]},
];

const state = {
  active: 0,
  activeType: 'player',   // 'player' | 'ball' | 'annot'
  mode: 'draw',
  courtType: 'doubles',
  homeSide: 'left',
  serveSide: 'none',
  lineWidth: 3,
  lineDash: 'solid',
  drawing: false,
  curStroke: [],
  pendingPlace: false,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Undo Stack
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MAX_UNDO = 60;
const undoStack = [];

function pushUndo(action) {
  undoStack.push(action);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undo() {
  if (undoStack.length === 0) return;
  const a = undoStack.pop();
  let arr;
  if (a.who === 'player') arr = PLAYERS;
  else if (a.who === 'ball') arr = BALLS;
  else arr = ANNOTS;

  const entity = arr[a.id];
  switch (a.type) {
    case 'stroke':       entity.strokes.pop(); break;
    case 'place':        entity.pos = a.from; break;
    case 'erase-marker': entity.pos = a.pos; break;
    case 'erase-stroke': entity.strokes.splice(a.idx, 0, a.stroke); break;
  }
  redraw();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Canvas Setup
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const courtC    = document.getElementById('court-canvas');
const drawC     = document.getElementById('draw-canvas');
const cc        = courtC.getContext('2d');
const dc        = drawC.getContext('2d');
const wrapper   = document.getElementById('court-wrapper');
const container = document.getElementById('court-container');

// ç¾½çƒå ´åœ‹éš›æ¨™æº– (å…¬å°º)
const COURT_W = 13.4;
const COURT_H = 6.1;
const MARGIN  = 18;

let CW=0, CH=0, SC=1, OFFSET_X=0, OFFSET_Y=0;

function computeScale() {
  const scW = (CW - MARGIN*2) / COURT_W;
  const scH = (CH - MARGIN*2) / COURT_H;
  SC = Math.min(scW, scH);
  OFFSET_X = (CW - COURT_W * SC) / 2;
  OFFSET_Y = (CH - COURT_H * SC) / 2;
}

function resize() {
  const cr    = container.getBoundingClientRect();
  const availW = cr.width  - 12;
  const availH = cr.height - 12;
  const aspect = COURT_W / COURT_H;
  let w, h;
  if (availW / availH > aspect) { h=availH; w=h*aspect; }
  else                           { w=availW; h=w/aspect; }
  CW = Math.floor(w); CH = Math.floor(h);
  [courtC, drawC].forEach(c => { c.width=CW; c.height=CH; });
  wrapper.style.cssText = `width:${CW}px;height:${CH}px;`;
  computeScale();
  redraw();
  initTrainCanvas();
  drawTrainLights();
}

const cx = m => OFFSET_X + m * SC;
const cy = m => OFFSET_Y + m * SC;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// å ´åœ°ç¹ªè£½
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawCourt() {
  const c = cc;
  c.clearRect(0,0,CW,CH);
  c.fillStyle = '#ffffff';
  c.fillRect(0,0,CW,CH);

  // ä¸»å®¢å ´åº•è‰²
  const homeLeft  = state.homeSide === 'left';
  const homeColor = 'rgba(52,152,219,0.06)';
  const awayColor = 'rgba(231,76,60,0.06)';
  c.fillStyle = homeLeft ? homeColor : awayColor;
  c.fillRect(cx(0), cy(0), cx(COURT_W/2)-cx(0), cy(COURT_H)-cy(0));
  c.fillStyle = homeLeft ? awayColor : homeColor;
  c.fillRect(cx(COURT_W/2), cy(0), cx(COURT_W)-cx(COURT_W/2), cy(COURT_H)-cy(0));

  // å–®æ‰“é‚Šå€é™°å½±
  if (state.courtType === 'singles') {
    c.fillStyle = 'rgba(0,0,0,0.07)';
    c.fillRect(cx(0), cy(0),            cx(COURT_W)-cx(0), cy(0.46)-cy(0));
    c.fillRect(cx(0), cy(COURT_H-0.46), cx(COURT_W)-cx(0), cy(COURT_H)-cy(COURT_H-0.46));
  }

  // æµ®æ°´å°
  const wCX = cx(COURT_W/2);
  const wCY = cy(COURT_H/2);
  c.save();
  c.globalAlpha = 0.06;
  const wFs = Math.round(Math.min(COURT_W, COURT_H) * SC * 0.13);
  c.font = `bold italic ${wFs}px 'Helvetica Neue',Arial,sans-serif`;
  c.fillStyle = '#1a4080';
  c.textAlign = 'center'; c.textBaseline = 'middle';
  c.fillText('Mido Learning', wCX, wCY - wFs * 0.6);
  const wFs2 = Math.round(wFs * 0.45);
  c.font = `${wFs2}px Arial,sans-serif`;
  c.fillText('ç¾½çƒæˆ°è¡“ç‰ˆ', wCX, wCY + wFs2 * 0.3);
  c.restore();

  // å ´åœ°ç·š
  c.strokeStyle = '#1a1a8e';
  c.lineWidth = 2;
  c.setLineDash([]);
  c.lineCap = 'square';
  c.strokeRect(cx(0), cy(0), cx(COURT_W)-cx(0), cy(COURT_H)-cy(0));

  // é•·ç™¼çƒç·š (0.76m)
  line(c, cx(0.76),         cy(0), cx(0.76),         cy(COURT_H));
  line(c, cx(COURT_W-0.76), cy(0), cx(COURT_W-0.76), cy(COURT_H));

  // çŸ­ç™¼çƒç·š (1.98m from net)
  const ssl = COURT_W/2 - 1.98;
  line(c, cx(ssl),         cy(0), cx(ssl),         cy(COURT_H));
  line(c, cx(COURT_W-ssl), cy(0), cx(COURT_W-ssl), cy(COURT_H));

  // å–®æ‰“é‚Šç·š
  line(c, cx(0), cy(0.46),         cx(COURT_W), cy(0.46));
  line(c, cx(0), cy(COURT_H-0.46), cx(COURT_W), cy(COURT_H-0.46));

  // ä¸­ç·š
  line(c, cx(0.76),        cy(COURT_H/2), cx(ssl),          cy(COURT_H/2));
  line(c, cx(COURT_W-ssl), cy(COURT_H/2), cx(COURT_W-0.76), cy(COURT_H/2));

  // çƒç¶²
  c.strokeStyle = '#555'; c.lineWidth = 3;
  line(c, cx(COURT_W/2), cy(0), cx(COURT_W/2), cy(COURT_H));

  // çƒæŸ±
  c.fillStyle = '#333';
  dot(c, cx(COURT_W/2), cy(0),       5);
  dot(c, cx(COURT_W/2), cy(COURT_H), 5);

  drawServe(c);
}

function line(c,x1,y1,x2,y2){c.beginPath();c.moveTo(x1,y1);c.lineTo(x2,y2);c.stroke();}
function dot(c,x,y,r){c.beginPath();c.arc(x,y,r,0,Math.PI*2);c.fill();}

function drawServe(c) {
  const flag = document.getElementById('serve-flag');
  if (state.serveSide === 'none') { flag.style.display='none'; return; }
  const isLeft = state.serveSide === 'left';
  const px = isLeft ? cx(1.5) : cx(COURT_W-1.5);
  const py = cy(COURT_H/2);
  flag.style.display = 'block';
  flag.style.left = (px-12)+'px';
  flag.style.top  = (py-12)+'px';
  c.fillStyle = 'rgba(241,196,15,0.18)';
  c.beginPath(); c.arc(px, py, 20, 0, Math.PI*2); c.fill();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// èµ°ç·šç¹ªè£½
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawStrokes(ctx) {
  PLAYERS.forEach(p => {
    if (!p.visible) return;
    p.strokes.forEach(s => paintStroke(ctx, s.pts, p.color, s.w, s.dash));
  });
  BALLS.forEach(b => {
    if (!b.visible) return;
    b.strokes.forEach(s => paintStroke(ctx, s.pts, b.color, s.w, s.dash));
  });
  ANNOTS.forEach(a => {
    a.strokes.forEach(s => paintStroke(ctx, s.pts, a.color, s.w, s.dash));
  });
}

function paintStroke(ctx, pts, color, w, dash) {
  if (pts.length < 2) return;
  const dashPat = dash==='dashed'?[w*3,w*2]:[];
  ctx.lineCap = 'round'; ctx.lineJoin = 'round';
  ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = w + 3;
  ctx.setLineDash(dashPat);
  ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y);
  for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
  ctx.stroke();
  ctx.strokeStyle = color; ctx.lineWidth = w;
  ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y);
  for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
  ctx.stroke(); ctx.setLineDash([]);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// æ¨™è¨˜ç¹ªè£½ï¼ˆçƒå“¡ & çƒï¼‰
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MR = 15; // çƒå“¡åŠå¾‘
const BR = 12; // çƒåŠå¾‘

function drawMarkers(ctx) {
  PLAYERS.forEach(p => {
    if (!p.visible || !p.pos) return;
    const isActive = (p.id===state.active && state.activeType==='player');
    drawPlayerMarker(ctx, p.pos.x, p.pos.y, p.color, p.name, p.id, isActive);
  });
  BALLS.forEach(b => {
    if (!b.visible || !b.pos) return;
    const isActive = (b.id===state.active && state.activeType==='ball');
    drawShuttleMarker(ctx, b.pos.x, b.pos.y, isActive);
  });
}

function drawPlayerMarker(ctx, x, y, color, name, id, isActive) {
  ctx.save();
  ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=7;
  ctx.shadowOffsetX=2; ctx.shadowOffsetY=2;

  // åº•è‰²åœ“
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x, y, MR, 0, Math.PI*2);
  ctx.fill();

  // é‚Šæ¡†
  ctx.strokeStyle = isActive ? '#fff' : 'rgba(255,255,255,0.4)';
  ctx.lineWidth = isActive ? 2.5 : 1.5;
  ctx.stroke();

  ctx.shadowColor='transparent'; ctx.shadowBlur=0;
  ctx.shadowOffsetX=0; ctx.shadowOffsetY=0;

  // çƒå“¡è™Ÿç¢¼ï¼ˆå¤§ï¼Œç™½è‰²ï¼‰
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.round(MR*0.95)}px sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(name, x, y);

  // é¸ä¸­è™›ç·šå¤–åœˆ
  if (isActive) {
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth = 1.5; ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.arc(x, y, MR+5, 0, Math.PI*2);
    ctx.stroke(); ctx.setLineDash([]);
  }

  ctx.restore();
}

// â”€â”€ ç¾½çƒ iconï¼ˆç¨‹å¼ç¹ªè£½ï¼‰â”€â”€
function drawShuttleMarker(ctx, x, y, isActive) {
  const r = BR;
  ctx.save();
  ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=7;
  ctx.shadowOffsetX=2; ctx.shadowOffsetY=2;

  // åº•è‰²åœ“ï¼ˆæ·±è‰²èƒŒæ™¯ï¼‰
  ctx.fillStyle = 'rgba(30,36,55,0.92)';
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = isActive ? '#fff' : 'rgba(255,255,255,0.35)';
  ctx.lineWidth = isActive ? 2.5 : 1.5;
  ctx.stroke();

  ctx.shadowColor='transparent'; ctx.shadowBlur=0;
  ctx.shadowOffsetX=0; ctx.shadowOffsetY=0;

  // â”€â”€ ç¾½çƒåœ–ç¤º â”€â”€
  const bx = x, by = y;
  const featherR = r * 0.75;    // ç¾½æ¯›æ•£é–‹åŠå¾‘
  const corkR    = r * 0.32;    // è»Ÿæœ¨é ­åŠå¾‘
  const corkCY   = by + r * 0.28; // è»Ÿæœ¨é ­ä½ç½®ï¼ˆä¸‹æ–¹åç§»ï¼‰
  const quillBase = by + r * 0.1; // ç¾½æ¯›æ ¹éƒ¨

  // ç¹ªè£½ç¾½æ¯›ç·šï¼ˆæ‰‡å½¢æ•£é–‹ï¼‰
  const numF = 9;
  for (let i = 0; i < numF; i++) {
    const t    = i / (numF - 1);  // 0..1
    const ang  = (-Math.PI * 0.72) + t * (Math.PI * 1.44); // æ‰‡å½¢è§’åº¦
    const tipX = bx + Math.cos(ang) * featherR;
    const tipY = (by - featherR * 0.55) + Math.sin(ang) * featherR * 0.35;

    ctx.beginPath();
    ctx.moveTo(bx, quillBase);
    ctx.lineTo(tipX, tipY);
    ctx.strokeStyle = 'rgba(255,255,255,0.72)';
    ctx.lineWidth = 0.9;
    ctx.stroke();
  }

  // ç¾½æ¯›é ‚ç«¯å¼§ï¼ˆæ©¢åœ“å½¢ï¼‰
  ctx.beginPath();
  ctx.ellipse(bx, by - featherR * 0.3, featherR * 0.82, featherR * 0.28, 0, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 0.85;
  ctx.stroke();

  // è»Ÿæœ¨é ­ï¼ˆåœ“å½¢ï¼Œç±³é»ƒè‰²ï¼‰
  ctx.beginPath(); ctx.arc(bx, corkCY, corkR, 0, Math.PI*2);
  const grad = ctx.createRadialGradient(bx-corkR*0.3, corkCY-corkR*0.3, 0, bx, corkCY, corkR);
  grad.addColorStop(0, '#f5e6b0');
  grad.addColorStop(1, '#c8a85a');
  ctx.fillStyle = grad; ctx.fill();
  ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 0.8; ctx.stroke();

  // é¸ä¸­å¤–åœˆ
  if (isActive) {
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth = 1.5; ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.arc(x, y, r+5, 0, Math.PI*2);
    ctx.stroke(); ctx.setLineDash([]);
  }

  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// å…¨éƒ¨é‡ç¹ª
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function redraw() {
  drawCourt();
  dc.clearRect(0,0,CW,CH);
  drawStrokes(dc);
  // æ­£åœ¨ç•«çš„ç·š
  if (state.drawing && state.curStroke.length > 1) {
    const color = getDrawColor();
    paintStroke(dc, state.curStroke, color, state.lineWidth, state.lineDash);
  }
  drawMarkers(dc);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// è¼”åŠ©
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getActiveEntity() {
  if (state.activeType === 'player') return PLAYERS[state.active];
  if (state.activeType === 'ball')   return BALLS[state.active];
  return ANNOTS[state.active]; // annot
}
function getDrawColor() {
  return getActiveEntity().color;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// äº‹ä»¶åº§æ¨™
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function pos(e) {
  const r=drawC.getBoundingClientRect();
  const sx=drawC.width/r.width, sy=drawC.height/r.height;
  let ex,ey;
  if (e.touches?.length)           {ex=e.touches[0].clientX;       ey=e.touches[0].clientY;}
  else if (e.changedTouches?.length){ex=e.changedTouches[0].clientX;ey=e.changedTouches[0].clientY;}
  else                              {ex=e.clientX; ey=e.clientY;}
  return {x:(ex-r.left)*sx, y:(ey-r.top)*sy};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// æ‹–æ›³
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let drag=null, dragOff={x:0,y:0};

function hitMarker(p) {
  for (let i=PLAYERS.length-1;i>=0;i--) {
    const pl=PLAYERS[i];
    if (!pl.visible||!pl.pos) continue;
    if (Math.hypot(p.x-pl.pos.x, p.y-pl.pos.y) <= MR+5) return {who:'player',id:i};
  }
  for (let i=BALLS.length-1;i>=0;i--) {
    const bl=BALLS[i];
    if (!bl.visible||!bl.pos) continue;
    if (Math.hypot(p.x-bl.pos.x, p.y-bl.pos.y) <= BR+5) return {who:'ball',id:i};
  }
  return null;
}
function entityAt(hit) {
  return hit.who === 'player' ? PLAYERS[hit.id] : BALLS[hit.id];
}

function onDown(e) {
  e.preventDefault();
  const p = pos(e);
  if (state.mode==='place') {
    const h = hitMarker(p);
    if (h) {
      drag=h; dragOff={x:p.x-entityAt(h).pos.x, y:p.y-entityAt(h).pos.y};
      selectEntity(h.who, h.id);
    } else {
      const ae = getActiveEntity();
      if (state.activeType === 'annot') return; // æ¨™è¨˜æ¨¡å¼ç„¡æ£‹å­
      const oldPos = ae.pos ? {...ae.pos} : null;
      ae.pos = {x:p.x, y:p.y};
      pushUndo({type:'place', who:state.activeType, id:state.active, from:oldPos});
      redraw();
    }
    return;
  }
  if (state.mode==='erase') {
    const h = hitMarker(p);
    if (h) {
      const ent = entityAt(h);
      pushUndo({type:'erase-marker', who:h.who, id:h.id, pos:{...ent.pos}});
      ent.pos = null;
    } else {
      eraseNear(p);
    }
    redraw(); return;
  }
  // draw mode
  const h = hitMarker(p);
  if (h) {
    drag=h; dragOff={x:p.x-entityAt(h).pos.x, y:p.y-entityAt(h).pos.y};
    selectEntity(h.who, h.id); return;
  }
  // ä¸€æ¬¡æ€§æ”¾ç½®
  if (state.pendingPlace && state.activeType !== 'annot') {
    const ae = getActiveEntity();
    pushUndo({type:'place', who:state.activeType, id:state.active, from:null});
    ae.pos = {x:p.x, y:p.y};
    state.pendingPlace = false;
    updateCursor(); renderHUD(); redraw();
    return;
  }
  state.drawing = true;
  state.curStroke = [{x:p.x, y:p.y}];
}

function onMove(e) {
  e.preventDefault();
  const p = pos(e);
  if (drag) {
    entityAt(drag).pos = {x:p.x-dragOff.x, y:p.y-dragOff.y};
    redraw(); return;
  }
  if (state.drawing) { state.curStroke.push({x:p.x,y:p.y}); redraw(); }
}

function onUp(e) {
  e.preventDefault();
  if (drag) {
    pushUndo({type:'place', who:drag.who, id:drag.id, from:null});
    drag=null; redraw(); return;
  }
  if (state.drawing) {
    state.drawing = false;
    if (state.curStroke.length >= 2) {
      const ae = getActiveEntity();
      const stroke = {pts:[...state.curStroke], w:state.lineWidth, dash:state.lineDash};
      ae.strokes.push(stroke);
      pushUndo({type:'stroke', who:state.activeType, id:state.active});
    }
    state.curStroke = [];
    redraw();
  }
}

function eraseNear(p) {
  const checkArr = (arr, who) => {
    for (const ent of arr) {
      for (let i=ent.strokes.length-1;i>=0;i--) {
        for (const pt of ent.strokes[i].pts) {
          if (Math.hypot(pt.x-p.x,pt.y-p.y)<14) {
            const stroke=ent.strokes.splice(i,1)[0];
            pushUndo({type:'erase-stroke',who,id:ent.id,idx:i,stroke});
            return true;
          }
        }
      }
    }
    return false;
  };
  if (!checkArr(PLAYERS,'player'))
    if (!checkArr(BALLS,'ball'))
      checkArr(ANNOTS,'annot');
}

drawC.addEventListener('mousedown', onDown);
drawC.addEventListener('mousemove', onMove);
drawC.addEventListener('mouseup',   onUp);
drawC.addEventListener('mouseleave',onUp);
drawC.addEventListener('touchstart', onDown,{passive:false});
drawC.addEventListener('touchmove',  onMove,{passive:false});
drawC.addEventListener('touchend',   onUp,  {passive:false});
drawC.addEventListener('touchcancel',onUp,  {passive:false});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// æ§åˆ¶å‡½å¼
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setMode(m) {
  state.mode = m;
  ['draw','place','erase'].forEach(x => document.getElementById('btn-'+x).classList.toggle('on', x===m));
  updateCursor();
}

function setCourtType(t) {
  state.courtType = t;
  document.getElementById('btn-doubles').classList.toggle('on', t==='doubles');
  document.getElementById('btn-singles').classList.toggle('on', t==='singles');
  redraw();
}

function setServe(s) {
  state.serveSide = s;
  ['sl','sr','sn'].forEach(x => document.getElementById('btn-'+x).classList.remove('on'));
  if (s==='left')  document.getElementById('btn-sl').classList.add('on');
  if (s==='right') document.getElementById('btn-sr').classList.add('on');
  if (s==='none')  document.getElementById('btn-sn').classList.add('on');
  redraw();
}

function setHome(side) {
  state.homeSide = side;
  document.getElementById('btn-hl').classList.toggle('on', side==='left');
  document.getElementById('btn-hr').classList.toggle('on', side==='right');
  const ll = document.getElementById('lbl-left');
  const lr = document.getElementById('lbl-right');
  if (side==='left') {
    ll.textContent='ğŸ”µæˆ‘æ–¹'; ll.style.color='#3498db';
    lr.textContent='ğŸ”´å°æ–¹'; lr.style.color='#e74c3c';
  } else {
    ll.textContent='ğŸ”´å°æ–¹'; ll.style.color='#e74c3c';
    lr.textContent='ğŸ”µæˆ‘æ–¹'; lr.style.color='#3498db';
  }
  redraw();
}

function setDash(d) {
  state.lineDash = d;
  ['solid','dashed','arrow'].forEach(x => document.getElementById('btn-'+x).classList.toggle('on', x===d));
}

function clearActive() {
  const ae = getActiveEntity();
  ae.strokes = [];
  if (state.activeType !== 'annot') ae.pos = null;
  redraw();
}

function resetAll() {
  if (!confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰èµ°ç·šèˆ‡ç«™ä½ï¼Ÿ')) return;
  PLAYERS.forEach(p => { p.strokes=[]; p.pos=null; });
  BALLS.forEach(b   => { b.strokes=[]; b.pos=null; });
  ANNOTS.forEach(a  => { a.strokes=[]; });
  undoStack.length = 0;
  setServe('none');
  redraw();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HUD UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderHUD() {
  // çƒå“¡
  const pe = document.getElementById('hud-players');
  pe.innerHTML = '';
  pe.style.display = 'flex'; pe.style.gap = '5px';
  PLAYERS.forEach((p, i) => {
    const isActive  = (i===state.active && state.activeType==='player');
    const isPending = isActive && state.pendingPlace;
    const b = document.createElement('button');
    b.className = 'hud-player' + (isPending?' pending':isActive?' sel':'');
    b.style.setProperty('--c', p.color);
    b.title = `${p.label} [${i+1}]`;
    b.innerHTML = `<span class="pnum">${p.name}</span><span class="plbl">${p.label}</span>`;
    b.onclick = () => selectEntity('player', i);
    pe.appendChild(b);
  });

  // çƒï¼ˆåªæœ‰ 1 å€‹ï¼‰
  const be = document.getElementById('hud-ball');
  be.innerHTML = '';
  be.style.display = 'flex';
  const ball = BALLS[0];
  const ballActive  = (state.activeType==='ball' && state.active===0);
  const ballPending = ballActive && state.pendingPlace;
  const bb = document.createElement('button');
  bb.className = 'hud-ball' + (ballPending?' pending':ballActive?' sel':'');
  bb.title = 'ç¾½çƒ [5]';
  // ç•«è¿·ä½ ç¾½çƒåœ–ç¤º
  bb.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24">
    <g transform="translate(12,12)">
      <!-- feathers -->
      <line x1="0" y1="2"  x2="-7" y2="-8" stroke="rgba(255,255,255,0.7)" stroke-width="1"/>
      <line x1="0" y1="2"  x2="-5" y2="-9" stroke="rgba(255,255,255,0.7)" stroke-width="1"/>
      <line x1="0" y1="2"  x2="-2" y2="-9.5" stroke="rgba(255,255,255,0.7)" stroke-width="1"/>
      <line x1="0" y1="2"  x2="1"  y2="-9.5" stroke="rgba(255,255,255,0.7)" stroke-width="1"/>
      <line x1="0" y1="2"  x2="4"  y2="-9"   stroke="rgba(255,255,255,0.7)" stroke-width="1"/>
      <line x1="0" y1="2"  x2="6.5" y2="-8"  stroke="rgba(255,255,255,0.7)" stroke-width="1"/>
      <!-- feather arc -->
      <ellipse cx="0" cy="-8" rx="6" ry="2" fill="none" stroke="rgba(255,255,255,0.45)" stroke-width="0.9"/>
      <!-- cork -->
      <circle cx="0" cy="5" r="3.2" fill="#dab86a" stroke="rgba(0,0,0,0.3)" stroke-width="0.8"/>
    </g>
  </svg>`;
  bb.onclick = () => selectEntity('ball', 0);
  be.appendChild(bb);

  // æ¨™è¨˜é¡è‰²
  const ae = document.getElementById('hud-annots');
  ae.innerHTML = '';
  ANNOTS.forEach((a, i) => {
    const isActive = (i===state.active && state.activeType==='annot');
    const btn = document.createElement('button');
    btn.className = 'hud-annot' + (isActive?' sel':'');
    btn.style.setProperty('--c', a.color);
    btn.title = a.label + ' æ¨™è¨˜';
    btn.onclick = () => selectEntity('annot', i);
    ae.appendChild(btn);
  });
}

function selectEntity(type, i) {
  state.activeType = type;
  state.active = i;
  if (type !== 'annot') {
    const ent = type === 'player' ? PLAYERS[i] : BALLS[i];
    state.pendingPlace = !ent.pos;
  } else {
    state.pendingPlace = false;
  }
  updateCursor();
  renderHUD();
  redraw();
}

function hideToolbar() {
  document.getElementById('toolbar').style.display = 'none';
  document.getElementById('toolbar-reveal').style.display = 'block';
  resize(); // é‡æ–°è¨ˆç®—å ´åœ°å¤§å°
}

function showToolbar() {
  document.getElementById('toolbar').style.display = 'flex';
  document.getElementById('toolbar-reveal').style.display = 'none';
  resize();
}

function hideHud() {
  document.getElementById('hud').style.display = 'none';
  document.getElementById('hud-reveal').style.display = 'block';
}

function showHud() {
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('hud-reveal').style.display = 'none';
}

function updateCursor() {
  if (state.pendingPlace) {
    drawC.style.cursor = 'copy';
  } else if (state.mode==='draw') {
    drawC.style.cursor = 'crosshair';
  } else if (state.mode==='erase') {
    drawC.style.cursor = 'cell';
  } else {
    drawC.style.cursor = 'move';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ç±³å­—æ­¥è¨“ç·´ç³»çµ±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TRAIN = {
  panelOpen: false,
  side: 'home',
  zones: { front: true, mid: true, back: true },
  interval: 2000,
  running: false,
  currentLight: -1,
  oppLight: -1,
  timer: null,
  pulse: 0,
  pulseDir: 1,
  rafId: null,
};

let trainC = null; // train canvas context

function initTrainCanvas() {
  const tc = document.getElementById('train-overlay');
  tc.width  = CW;
  tc.height = CH;
  tc.style.cssText = `position:absolute;top:0;left:0;width:${CW}px;height:${CH}px;pointer-events:none;`;
  trainC = tc.getContext('2d');
}

function getTrainPositions() {
  const homeLeft = state.homeSide === 'left';
  const trainLeft = (TRAIN.side === 'home') ? homeLeft : !homeLeft;
  const sTop = 0.46;
  const sBot = COURT_H - 0.46;
  const net  = COURT_W / 2;
  const ssl  = 1.98;   // short service line distance from net
  const lsl  = 0.76;   // long service line from back
  const midH = (COURT_H - 0.46 * 2) / 2 + 0.46;

  let fX, mX, bX;
  if (trainLeft) {
    fX = net - ssl;
    mX = (lsl + (net - ssl)) / 2;
    bX = lsl;
  } else {
    fX = net + ssl;
    mX = (COURT_W - lsl + (net + ssl)) / 2;
    bX = COURT_W - lsl;
  }

  return [
    { id: 'FL', x: fX, y: sTop,  zone: 'front', label: 'å‰å·¦' },
    { id: 'FR', x: fX, y: sBot,  zone: 'front', label: 'å‰å³' },
    { id: 'ML', x: mX, y: sTop,  zone: 'mid',   label: 'ä¸­å·¦' },
    { id: 'MR', x: mX, y: sBot,  zone: 'mid',   label: 'ä¸­å³' },
    { id: 'BL', x: bX, y: sTop,  zone: 'back',  label: 'å¾Œå·¦' },
    { id: 'BR', x: bX, y: sBot,  zone: 'back',  label: 'å¾Œå³' },
  ];
}

function getActiveTrainPositions() {
  return getTrainPositions().filter(p => TRAIN.zones[p.zone]);
}

function getOppPositions() {
  const homeLeft = state.homeSide === 'left';
  const trainLeft = (TRAIN.side === 'home') ? homeLeft : !homeLeft;
  const oppLeft = !trainLeft; // å°æ–¹åœ¨å¦ä¸€å´
  const sTop = 0.46;
  const sBot = COURT_H - 0.46;
  const net  = COURT_W / 2;
  const ssl  = 1.98;
  const lsl  = 0.76;
  let fX, mX, bX;
  if (oppLeft) {
    fX = net - ssl;
    mX = (lsl + (net - ssl)) / 2;
    bX = lsl;
  } else {
    fX = net + ssl;
    mX = (COURT_W - lsl + (net + ssl)) / 2;
    bX = COURT_W - lsl;
  }
  return [
    { id: 'OFL', x: fX, y: sTop },
    { id: 'OFR', x: fX, y: sBot },
    { id: 'OML', x: mX, y: sTop },
    { id: 'OMR', x: mX, y: sBot },
    { id: 'OBL', x: bX, y: sTop },
    { id: 'OBR', x: bX, y: sBot },
  ];
}

function drawTrainLights() {
  if (!trainC) return;
  const tc = document.getElementById('train-overlay');
  trainC.clearRect(0, 0, CW, CH);
  if (!TRAIN.panelOpen) { tc.style.display = 'none'; return; }
  tc.style.display = 'block';

  const homeLeft = state.homeSide === 'left';
  const trainLeft = (TRAIN.side === 'home') ? homeLeft : !homeLeft;

  // â”€â”€ 3D é€è¦–è§’é» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const cx0   = CW / 2;
  const nW2   = CW * 0.44;   // è¿‘ç«¯ï¼ˆçƒå“¡åº•ç·šï¼‰åŠå¯¬
  const fW2   = CW * 0.20;   // é ç«¯ï¼ˆå°æ‰‹åº•ç·šï¼‰åŠå¯¬
  const nearY = CH * 0.90;   // è¿‘ç«¯ Y åƒç´ 
  const farY  = CH * 0.09;   // é ç«¯ Y åƒç´ 

  const NL = { x: cx0 - nW2, y: nearY };
  const NR = { x: cx0 + nW2, y: nearY };
  const FL = { x: cx0 - fW2, y: farY  };
  const FR = { x: cx0 + fW2, y: farY  };

  // å…¬å°ºåº§æ¨™ (mx=æ·±åº¦ 0..COURT_W, my=æ©«å‘ 0..COURT_H) â†’ ç•«å¸ƒåƒç´ 
  function mapPt(mx, my) {
    const u = trainLeft ? mx / COURT_W : (COURT_W - mx) / COURT_W;
    const v = my / COURT_H;
    const lx = NL.x + u * (FL.x - NL.x);
    const ly = NL.y + u * (FL.y - NL.y);
    const rx = NR.x + u * (FR.x - NR.x);
    const ry = NR.y + u * (FR.y - NR.y);
    return { x: lx + v * (rx - lx), y: ly + v * (ry - ly) };
  }

  // é€è¦–ç¸®æ”¾åŠå¾‘
  function dotR(mx) {
    const u = trainLeft ? mx / COURT_W : (COURT_W - mx) / COURT_W;
    return Math.max(9, SC * 0.28) * (1.6 - 1.0 * u);
  }

  // ç•«å ´åœ°ç·šï¼ˆå…¬å°ºåº§æ¨™ï¼‰
  function line3D(x1, y1, x2, y2, col, w) {
    const a = mapPt(x1, y1), b = mapPt(x2, y2);
    trainC.beginPath();
    trainC.moveTo(a.x, a.y); trainC.lineTo(b.x, b.y);
    trainC.strokeStyle = col; trainC.lineWidth = w; trainC.stroke();
  }

  // â”€â”€ 1. æ·±è‰²èƒŒæ™¯ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  trainC.fillStyle = 'rgba(0,4,18,0.92)';
  trainC.fillRect(0, 0, CW, CH);

  // â”€â”€ 2. çƒå ´è¡¨é¢ï¼ˆé›™è‰²ç¶ åœ°ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const netL = mapPt(COURT_W / 2, 0);
  const netR = mapPt(COURT_W / 2, COURT_H);

  // çƒå“¡åŠå ´ï¼ˆè¿‘ç«¯ï¼Œè¼ƒäº®ç¶ ï¼‰
  trainC.beginPath();
  trainC.moveTo(NL.x, NL.y); trainC.lineTo(NR.x, NR.y);
  trainC.lineTo(netR.x, netR.y); trainC.lineTo(netL.x, netL.y);
  trainC.closePath();
  trainC.fillStyle = '#1b6b3e'; trainC.fill();

  // å°æ‰‹åŠå ´ï¼ˆé ç«¯ï¼Œè¼ƒæš—ç¶ ï¼‰
  trainC.beginPath();
  trainC.moveTo(netL.x, netL.y); trainC.lineTo(netR.x, netR.y);
  trainC.lineTo(FR.x, FR.y); trainC.lineTo(FL.x, FL.y);
  trainC.closePath();
  trainC.fillStyle = '#11472a'; trainC.fill();

  // â”€â”€ 3. å ´åœ°ç·š â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const lc = 'rgba(255,255,255,0.50)';
  const lw = Math.max(1, SC * 0.018);
  line3D(0, 0, 0, COURT_H, lc, lw);                          // çƒå“¡åº•ç·š
  line3D(COURT_W, 0, COURT_W, COURT_H, lc, lw);              // å°æ‰‹åº•ç·š
  line3D(0, 0, COURT_W, 0, lc, lw);                          // å·¦é‚Šç·š
  line3D(0, COURT_H, COURT_W, COURT_H, lc, lw);              // å³é‚Šç·š
  const sslD = 1.98;
  const dimL = 'rgba(255,255,255,0.28)';
  line3D(COURT_W/2 - sslD, 0, COURT_W/2 - sslD, COURT_H, dimL, lw); // çƒå“¡çŸ­ç™¼çƒç·š
  line3D(COURT_W/2 + sslD, 0, COURT_W/2 + sslD, COURT_H, dimL, lw); // å°æ‰‹çŸ­ç™¼çƒç·š
  line3D(COURT_W/2 - sslD, COURT_H/2, COURT_W/2 + sslD, COURT_H/2, dimL, lw); // ä¸­ç·š

  // â”€â”€ 4. çƒç¶²ï¼ˆ3D é«˜åº¦æ„Ÿï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const netHpx = (nearY - farY) * 0.075;
  trainC.beginPath();
  trainC.moveTo(netL.x, netL.y - netHpx); trainC.lineTo(netR.x, netR.y - netHpx);
  trainC.strokeStyle = '#e8dfa0'; trainC.lineWidth = Math.max(2, SC * 0.035); trainC.stroke();
  trainC.beginPath();
  trainC.moveTo(netL.x, netL.y); trainC.lineTo(netL.x, netL.y - netHpx);
  trainC.moveTo(netR.x, netR.y); trainC.lineTo(netR.x, netR.y - netHpx);
  trainC.strokeStyle = '#c8b060'; trainC.lineWidth = Math.max(2, SC * 0.03); trainC.stroke();

  const pts    = getTrainPositions();
  const oppPts = getOppPositions();

  // â”€â”€ 5. å°æ‰‹ç›®æ¨™é»ï¼ˆæ©˜è‰²ï¼Œé ç«¯ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  oppPts.forEach((p, i) => {
    const { x: px, y: py } = mapPt(p.x, p.y);
    const r = dotR(p.x);
    const isActive = (i === TRAIN.oppLight && TRAIN.running);
    if (isActive) {
      const glow = r * (1.5 + TRAIN.pulse * 0.8);
      const grad = trainC.createRadialGradient(px, py, r*0.2, px, py, glow);
      grad.addColorStop(0, 'rgba(255,160,0,0.9)'); grad.addColorStop(0.4, 'rgba(220,100,0,0.6)'); grad.addColorStop(1, 'rgba(180,60,0,0)');
      trainC.beginPath(); trainC.arc(px, py, glow, 0, Math.PI*2); trainC.fillStyle = grad; trainC.fill();
      trainC.beginPath(); trainC.arc(px, py, r, 0, Math.PI*2);
      trainC.fillStyle = '#ff9500'; trainC.fill();
      trainC.strokeStyle = '#fff'; trainC.lineWidth = 2; trainC.stroke();
      trainC.fillStyle = '#fff'; trainC.font = `bold ${Math.round(r*0.9)}px Arial`;
      trainC.textAlign = 'center'; trainC.textBaseline = 'middle'; trainC.fillText('Ã—', px, py);
    } else {
      trainC.beginPath(); trainC.arc(px, py, r*0.65, 0, Math.PI*2);
      trainC.fillStyle = 'rgba(255,120,0,0.15)'; trainC.fill();
      trainC.strokeStyle = 'rgba(255,150,0,0.45)'; trainC.lineWidth = 1.5; trainC.stroke();
    }
  });

  // â”€â”€ 6. çƒå“¡è¨“ç·´é»ï¼ˆç¶ è‰²ï¼Œè¿‘ç«¯ï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  pts.forEach((p, i) => {
    const { x: px, y: py } = mapPt(p.x, p.y);
    const r      = dotR(p.x);
    const isActive = (i === TRAIN.currentLight);
    const inZone   = TRAIN.zones[p.zone];
    const arrow    = p.zone === 'front' ? 'â†“' : 'â†‘';
    if (!inZone) {
      trainC.beginPath(); trainC.arc(px, py, r*0.5, 0, Math.PI*2);
      trainC.fillStyle = 'rgba(80,80,100,0.4)'; trainC.fill();
      trainC.strokeStyle = 'rgba(120,120,150,0.4)'; trainC.lineWidth = 1.5; trainC.stroke();
    } else if (isActive) {
      const glow = r * (1.5 + TRAIN.pulse * 0.8);
      const grad = trainC.createRadialGradient(px, py, r*0.2, px, py, glow);
      grad.addColorStop(0, 'rgba(0,255,100,0.9)'); grad.addColorStop(0.4, 'rgba(0,220,80,0.6)'); grad.addColorStop(1, 'rgba(0,180,60,0)');
      trainC.beginPath(); trainC.arc(px, py, glow, 0, Math.PI*2); trainC.fillStyle = grad; trainC.fill();
      trainC.beginPath(); trainC.arc(px, py, r, 0, Math.PI*2);
      trainC.fillStyle = '#00ff66'; trainC.fill();
      trainC.strokeStyle = '#fff'; trainC.lineWidth = 2; trainC.stroke();
      trainC.fillStyle = '#fff'; trainC.font = `bold ${Math.round(r*0.9)}px Arial`;
      trainC.textAlign = 'center'; trainC.textBaseline = 'middle'; trainC.fillText(arrow, px, py);
    } else {
      trainC.beginPath(); trainC.arc(px, py, r*0.65, 0, Math.PI*2);
      trainC.fillStyle = 'rgba(0,180,80,0.25)'; trainC.fill();
      trainC.strokeStyle = 'rgba(0,220,100,0.55)'; trainC.lineWidth = 1.5; trainC.stroke();
      trainC.fillStyle = 'rgba(180,255,200,0.7)'; trainC.font = `${Math.round(r*0.65)}px Arial`;
      trainC.textAlign = 'center'; trainC.textBaseline = 'middle'; trainC.fillText(arrow, px, py);
    }
  });
}

function trainPulseLoop() {
  if (!TRAIN.running) return;
  TRAIN.pulse += TRAIN.pulseDir * 0.05;
  if (TRAIN.pulse >= 1) { TRAIN.pulse = 1; TRAIN.pulseDir = -1; }
  if (TRAIN.pulse <= 0) { TRAIN.pulse = 0; TRAIN.pulseDir =  1; }
  drawTrainLights();
  TRAIN.rafId = requestAnimationFrame(trainPulseLoop);
}

function pickNextLight() {
  const pts = getTrainPositions();
  // ç”¨ index æ“ä½œï¼Œé¿å…ç‰©ä»¶åƒè€ƒæ¯”å°éŒ¯èª¤
  let pool = [];
  for (let i = 0; i < pts.length; i++) {
    if (TRAIN.zones[pts[i].zone] && i !== TRAIN.currentLight) pool.push(i);
  }
  if (pool.length === 0) {
    // å…¨éƒ¨ active éƒ½åªå‰©ç›®å‰é€™å€‹ï¼ˆåªé–‹1å€‹zoneä¸”åª1å€‹é»æ™‚ï¼‰
    for (let i = 0; i < pts.length; i++) {
      if (TRAIN.zones[pts[i].zone]) pool.push(i);
    }
  }
  if (pool.length === 0) return;
  TRAIN.currentLight = pool[Math.floor(Math.random() * pool.length)];
  // åŒæ™‚éš¨æ©Ÿé¸å°æ–¹è½é»ï¼ˆ6å€‹ä½ç½®ä¸­ä»»é¸ä¸€å€‹ï¼Œé¿å…èˆ‡ä¸Šæ¬¡ç›¸åŒï¼‰
  const oppPool = [0,1,2,3,4,5].filter(i => i !== TRAIN.oppLight);
  TRAIN.oppLight = oppPool[Math.floor(Math.random() * oppPool.length)];
  TRAIN.pulse = 0; TRAIN.pulseDir = 1;
}

function startTraining() {
  if (getActiveTrainPositions().length === 0) return;
  TRAIN.running = true;
  document.getElementById('train-start').textContent = 'â¹ åœæ­¢è¨“ç·´';
  document.getElementById('train-start').classList.add('running');
  pickNextLight();
  if (TRAIN.rafId) cancelAnimationFrame(TRAIN.rafId);
  TRAIN.rafId = requestAnimationFrame(trainPulseLoop);
  TRAIN.timer = setInterval(() => {
    pickNextLight();
  }, TRAIN.interval);
}

function stopTraining() {
  TRAIN.running = false;
  TRAIN.currentLight = -1;
  TRAIN.oppLight = -1;
  if (TRAIN.timer) { clearInterval(TRAIN.timer); TRAIN.timer = null; }
  if (TRAIN.rafId)  { cancelAnimationFrame(TRAIN.rafId); TRAIN.rafId = null; }
  document.getElementById('train-start').textContent = 'â–¶ é–‹å§‹è¨“ç·´';
  document.getElementById('train-start').classList.remove('running');
  drawTrainLights();
}

function toggleTraining() {
  if (TRAIN.running) stopTraining();
  else startTraining();
}

function toggleTrainPanel() {
  TRAIN.panelOpen = !TRAIN.panelOpen;
  document.getElementById('train-panel').classList.toggle('open', TRAIN.panelOpen);
  document.getElementById('btn-train').classList.toggle('on', TRAIN.panelOpen);
  if (!TRAIN.panelOpen) stopTraining();
  drawTrainLights();
}

function setTrainSide(side) {
  TRAIN.side = side;
  document.getElementById('tp-home').classList.toggle('on', side === 'home');
  document.getElementById('tp-away').classList.toggle('on', side === 'away');
  if (TRAIN.running) { stopTraining(); startTraining(); }
  else drawTrainLights();
}

function toggleTrainZone(zone) {
  TRAIN.zones[zone] = !TRAIN.zones[zone];
  document.getElementById('tp-' + zone).classList.toggle('on', TRAIN.zones[zone]);
  if (TRAIN.running) { stopTraining(); startTraining(); }
  else drawTrainLights();
}

function setTrainInterval(v) {
  const secs = (Math.round(v) * 0.2).toFixed(1);
  TRAIN.interval = Math.round(v) * 200;
  document.getElementById('tp-speed-val').textContent = secs + 's';
  if (TRAIN.running) { stopTraining(); startTraining(); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// éµç›¤å¿«æ·éµ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown', e => {
  if (e.target.tagName==='INPUT') return;
  const k = e.key.toLowerCase();
  if ((e.ctrlKey||e.metaKey)&&k==='z'){e.preventDefault();undo();return;}
  if (e.key==='Escape'&&state.pendingPlace){state.pendingPlace=false;updateCursor();renderHUD();return;}
  switch(k){
    case 'q': setMode('draw');  break;
    case 'w': setMode('place'); break;
    case 'e': setMode('erase'); break;
    case 'a': setServe('left');  break;
    case 'd': setServe('right'); break;
    case 'r': if(!e.ctrlKey) resetAll(); break;
    case 's': setCourtType(state.courtType==='doubles'?'singles':'doubles'); break;
    case '1': selectEntity('player',0); break;
    case '2': selectEntity('player',1); break;
    case '3': selectEntity('player',2); break;
    case '4': selectEntity('player',3); break;
    case '5': selectEntity('ball',0);   break;
    case '6': selectEntity('annot',0);  break;
    case '7': selectEntity('annot',1);  break;
    case '8': selectEntity('annot',2);  break;
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Resize
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(resize, 80);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// åˆå§‹åŒ–
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
renderHUD();
setServe('none');
resize();
</script>
</body>
</html>
